<?php

namespace SolubleTest\FlexStore\Source\DbWrapper;

use Soluble\FlexStore\Options;
use Soluble\FlexStore\Source\DbWrapper\QuerySource;
use Soluble\DbWrapper\Adapter\AdapterInterface;
use Soluble\DbWrapper\AdapterFactory;

/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.1 on 2013-10-14 at 12:05:43.
 */
class QuerySourceTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var QuerySource
     */
    protected $source;


    /**
     *
     * @var AdapterInterface
     */
    protected $adapter;


    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
        $zendAdapter = \SolubleTestFactories::getDbAdapter();

        $this->adapter = AdapterFactory::createAdapterFromZendDb2($zendAdapter);

        $query = "select * from user";

        $this->source = new QuerySource($this->adapter, $query);
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown()
    {
    }


    public function testGetData()
    {
        $source1 = $this->getNewSource();
        $source2 = $this->getNewSource();

        $data = $source1->getData();
        $this->isInstanceOf('Soluble\FlexStore\ResultSet\ResultSet');
        $d = $data->toArray();
        $this->assertInternalType('array', $d);
        $this->assertArrayHasKey('user_id', $d[0]);
        $this->assertArrayHasKey('email', $d[0]);



        $options = new Options();
        $options->setLimit(10, 0);

        $data2 = $source2->getData($options);
        $d2 = $data2->toArray();

        $this->assertInternalType('array', $d2);

        $this->assertArrayHasKey('user_id', $d2[0]);
        $this->assertArrayHasKey('email', $d2[0]);
        $this->assertEquals($d[0], $d2[0]);
    }



    public function testGetMetadata()
    {
        $metadata = $this->source->getMetadataReader();
        $this->assertInstanceOf('\Soluble\Metadata\Reader\AbstractMetadataReader', $metadata);
    }

    public function testGetColumnModel()
    {
        $columnModel = $this->source->getColumnModel();
        $this->assertInstanceOf('\Soluble\FlexStore\Column\ColumnModel', $columnModel);
        $columns = $columnModel->getColumns();
        $this->assertInstanceOf('ArrayObject', $columns);
        foreach ($columns as $column) {
            $this->assertFalse($column->isVirtual());
        }
    }

    public function testGetMetadatareader()
    {
        $source = $this->getNewSource();
        $mr = $source->getMetadataReader();
        $this->assertInstanceOf('Soluble\Metadata\Reader\AbstractMetadataReader', $mr);
    }


    public function testCalcFoundRowsAndWithZeroLimit()
    {
        $source = new QuerySource($this->adapter, "select * from product");

        $options = new Options();
        $options->setLimit(0, 0);

        $data = $source->getData($options);
        $this->assertEquals(0, $data->count());
        $this->assertEquals(0, $data->getTotalRows());

        // Edge, test if SQL_CALC_FOUND_ROWS was really injected
        $query = $source->getQueryString();
        $this->assertNotContains('SQL_CALC_FOUND_ROWS', $query);
        $this->assertContains('LIMIT 0 OFFSET 0', $query);
    }


    public function testCalcFoundRowsAndOptions()
    {
        $source = new QuerySource($this->adapter, "select * from product");

        $options = new Options();
        $options->setLimit(2, 0);

        $data = $source->getData($options);

        $this->assertEquals(2, $data->count());
        $this->assertGreaterThan(2, $data->getTotalRows());

        // Edge, test if SQL_CALC_FOUND_ROWS was really injected
        $query = $source->getQueryString();
        $this->assertContains('SQL_CALC_FOUND_ROWS', $query);
        $this->assertContains('LIMIT 2 OFFSET 0', $query);
    }


    /**
     *
     * @return QuerySource
     */
    protected function getNewSource()
    {
        $source = new QuerySource($this->adapter, "select * from user");
        return $source;
    }
}
